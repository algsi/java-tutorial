# Java  8新特性：内部迭代和外部迭代（external iteration vs internal iteration）

Java8 增加了新的语言特性（例如 lambda 表达式和默认方法），为此 Java8 的类库也进行了很多改进，例如从外部迭代到内部迭代的改变。
集合类库主要依赖于外部迭代（external iteration）。Collection 实现 Iterable 接口，从而使得用户可以依次遍历集合的元素。比如我们需要把一个集合中的形状都设置成红色，那么可以这么写：

```java
for (Shape sheap : shapes) {
    shape.setColor(RED);
}
```

这个例子演示了外部迭代：for-each 循环调用 shapes 的 iterator() 方法进行依次遍历。外部循环的代码非常直接，但它有如下问题：
（1）Java 的 for 循环是串行的，而且必须按照集合中元素的顺序进行依次处理；
（2）集合框架无法对控制流进行优化，例如通过排序、并行、短路（short-circuiting）求值以及惰性求值改善性能。

尽管有时 for-each 循环的这些特性（串行，依次）是我们所期待的，但它对改善性能造成了阻碍。实际上，我们可以使用内部迭代（internal iteration）替代外部迭代，用户把对迭代的控制权交给类库，并向类库传递迭代时所需执行的代码。下面是前例的内部迭代代码：

```java
shapes.forEach(s -> s.setColor(RED));
```

尽管看起来只是一个小小的语法改动，但是它们的实际差别非常巨大。用户把对操作的控制权交还给类库，从而允许类库进行各种各样的优化（例如乱序执行、惰性求值和并行等等）。总的来说，内部迭代使得外部迭代中不可能实现的优化成为可能。
如上所示：外部迭代同时承担了做什么（把形状设为红色）和怎么做（得到 Iterator 实例然后依次遍历）两项职责，而内部迭代只负责做什么，而把怎么做留给类库。通过这样的职责发生了转变：用户的代码会变得更加清晰，而类库则可以进行各种优化，从而使所有用户都从中受益。

