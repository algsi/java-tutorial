# <font color=red>Java字符串</font>

<font color=red></font>

### <font color=red>String源码分析</font>

1. 底层是一个字符数组，且数组一旦初始化便不可以被改变，为final类型。

		/** The value is used for character storage. */
    	private final char value[];

2. 存储字符串的hashcode。

		/** Cache the hash code for the string */
    	private int hash; // Default to 0

3. 常见的构造方法。

	- 初始化为一个空字符串，但是使用这个构造方法不是必要的，因为一旦初始化便不能改变

			public String() {
        	this.value = "".value;
        	}

	- 用一个原来的一个字符串初始化这个字符串

        	public String(String original) {
        	this.value = original.value;
        	this.hash = original.hash;
    		}

    - 用一个字符数组来初始化初始化字符串，并且字符数组的改变并不影响新创建的字符串

        	public String(char value[]) {
        	this.value = Arrays.copyOf(value, value.length);
    		}

	- 使用一个字符串，以及偏移量和位数来初始化，其中count将为字符串的长度

             public String(char value[], int offset, int count) {
                if (offset < 0) {
                    throw new StringIndexOutOfBoundsException(offset);
                }
                if (count <= 0) {
                    if (count < 0) {
                        throw new StringIndexOutOfBoundsException(count);
                    }
                    if (offset <= value.length) {
                        this.value = "".value;  //空串
                        return;
                    }
                }
                // Note: offset or count might be near -1>>>1.
                if (offset > value.length - count) {
                    throw new StringIndexOutOfBoundsException(offset + count);
                }
                this.value = Arrays.copyOfRange(value, offset, offset+count);
            }
4. length()方法

		public int length() {
        	return value.length;
    	}

5. isEmpty()：判断字符串是否为空串

		public boolean isEmpty() {
        	return value.length == 0;
    	}

6. charAt(int index)：返回指定索引位置的字符

		public char charAt(int index) {
        	if ((index < 0) || (index >= value.length)) {
            	throw new StringIndexOutOfBoundsException(index);
        	}
        	return value[index];
    	}

7. equals(String s)：如果当前字符串与目标字符串s完全相同，返回true，否则返回false

		public boolean equals(Object anObject) {
        	if (this == anObject) {
            	return true;
        	}
        	if (anObject instanceof String) { //数据类型检测
            	String anotherString = (String)anObject;//强制转换
            	int n = value.length;
            	if (n == anotherString.value.length) {
                	char v1[] = value;
                	char v2[] = anotherString.value;
                	int i = 0;
                	while (n-- != 0) {
                    	if (v1[i] != v2[i])
                        	return false;
                    	i++;
                	}
                	return true;
            	}
        	}
        	return false;   //不是String类型
    	}

8. compareTo(String s)：当前字符串与目标字符串s按字典序比较，如果当前字符串与s相同返回0，如果大于s，返回正数，否则返回负数

		public int compareTo(String anotherString) {
            int len1 = value.length;
            int len2 = anotherString.value.length;
            int lim = Math.min(len1, len2);
            char v1[] = value;
            char v2[] = anotherString.value;

            int k = 0;
            while (k < lim) {
                char c1 = v1[k];
                char c2 = v2[k];
                if (c1 != c2) {
                    return c1 - c2;
                }
                k++;
            }
            return len1 - len2;
    	}

9. startsWith(String s)：判断当前字符串是否由目标字符串s开头，如果是返回true，否则返回false

		/**
     	* Tests if the substring of this string beginning at the
     	* specified index starts with the specified prefix.
     	* 测试字符串是否在指定的位置包含指定的字符串
     	*/
    	public boolean startsWith(String prefix, int toffset) {
            char ta[] = value;
            int to = toffset;
            char pa[] = prefix.value;
            int po = 0;
            int pc = prefix.value.length;
            // Note: toffset might be near -1>>>1.
            if ((toffset < 0) || (toffset > value.length - pc)) {
                return false;
            }
            while (--pc >= 0) {
                if (ta[to++] != pa[po++]) {
                    return false;
                }
            }
            return true;
    	}
10. endsWith(String s)：判断当前字符串是否由目标字符串s结尾，如果是返回true，否则返回false

		public boolean endsWith(String suffix) {
        	return startsWith(suffix, value.length - suffix.value.length);
    	}

11. indexOf(String s)：从当前字符串的起始位置检索目标字符串s第一次出现的位置（从0开始计数），如果没有检索到s返回-1

12. lastIndexOf(String s)：从当前字符串的起始位置检索目标字符串s最后一次出现的位置（从0开始计数），如果没有检索到s返回-1

13. indexOf(String s, int start)：从当前字符串的start位置开始检索目标字符串s第一次出现的位置（从0开始计数），如果没有检索到s返回-1

14. lastIndexOf(String s, int end)：从当前字符串的起始位置开始，到end位置结束，检索目标字符串s最后一次出现的位置（从0开始计数），如果没有检索到s返回-1

15. substring(int start)：返回当前字符串从start开始截取到当前字符串末尾的部分。

16. substring(int start, int end)：返回当前字符串从start开始截取到当前字符串末尾的部分（包含起始位置处的字符）。

		public String substring(int beginIndex) {
            if (beginIndex < 0) {
                throw new StringIndexOutOfBoundsException(beginIndex);
            }
            int subLen = value.length - beginIndex;
            if (subLen < 0) {
                throw new StringIndexOutOfBoundsException(subLen);
            }
            return (beginIndex == 0) ? this : new String(value, beginIndex, subLen);
    	}

17. substring(int start, int end):返回当前字符串，从start开始截取到end之前的部分(截取坐标为start开始，终点坐标为end-1，并包含在内)。

18. replaceAll(String old, String new)：返回当前字符串用new替换old的结果（old表示原字符串中的一个子串）

19. trim()：返回当前字符串去掉起始和结束位置的全部空格的字符串

20. split(String sign)：返回一个数组，该数组由目标字符串根据sign拆分得到。




