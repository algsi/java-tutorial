 # <font color=red>面向对象——上转型</font>

### <font color=red>定义</font>

父类声明，子类实例化的对象称为上转型对象。

### <font color=red>上转型对象的使用</font>

- 上转对象不能操作子类新增的成员变量，失掉了这部分属性，不能使用子类新增的方法，失掉了一些功能。

- 上转型对象可以操作子类继承的成员变量，也可以使用子类继承的或重写的方法。

- 如果子类重写了父类的某个方法后，当对象的上转型对象调用这个方法时一定是调用了子类重写的方法。因为程序在运行时知道，这个上转对象的实例是子类创建的，只不过损失了一些功能而已。

- 可以将上转型对象再强制转换为一个子类对象，此时对象又具备了子类所有属性和功能（即将上转型对象还原为子类对象）。

- 不可以将父类创建的对象赋值给子类声明的对象。

### <font color=red>关键字final</font>

final关键字可以用来修饰类、方法和变量。

- final修饰的类不能被继承。

- final修饰的方法不能被重写。

- final修饰的变量是常量，不能修改其值。

### <font color=red>关键字abstract（抽象）</font>

- abstract关键字可以用来修饰类和方法。

- 由abstract修饰的类叫做抽象类，该类不能被实例化，也就是不能使用关键字new来创建该类对象。

- 由abstract修饰的方法叫做抽象方法，抽象方法只有声明部分，而没有具体的方法体。

抽象类重要规则

- 如果一个<font color=green>非抽象类</font>是一个abstract类的子类，它必须具体实现父类的**所有**abstract方法，抽象类也可以继承抽象类，但是不用实现抽象父类中的abstract方法。

- 如果一个类中含有abstract方法，那么这个类必须用abstract来修饰（abstract类也可以没有abstract方法，但abstract方法必须出现在abstract类中）。

- 一个abstract类只关心它的子类是否具有某种功能，并不关心功能的具体行为，功能的具体行为由子类负责实现。

### <font color=red>接口</font>

- 当一个抽象类中的方法全部为抽象方法时，可以使用interface关键字将这个抽象类定义为接口。

- 在java中一个类只能有一个父类，如果某个类需要继承多个类的变量（状态）和方法（行为），那么java提供了接口方式，一个类可以实现多个接口，以获得多重继承的特性。

- 创建接口的语法格式如下:

		interface <接口名> {}
        
接口的访问级别

接口声明时，如果关键字interface前面加上public关键字，就称这样的接口是一个公有接口，公有接口可以被任何一个类使用。如果一个接口没有public修饰，接口为友好级别，友好接口可以被同一包中的其他类访问。


### <font color=red>关键字implements</font>

- 当一个类需要实现某个接口时，使用implements关键字。

- 如果一个类实现了多个接口的时候，用“,”分割多个接口的名称

- 在类中实现接口的方法时，方法的名字、返回类型、参数个数及参数类型必须与接口中的完全一致。

- 如果一个类实现了一个接口，但没有实现接口中的所有方法，那么这个类必须是abstract类。

### <font color=red>接口与抽象类的区别</font>

![接口与抽象类的区别.PNG](http://img.blog.csdn.net/20180219212219280)

### <font color=red>接口回调</font>

- 接口声明，实现类实例化的对象叫做接口回调。

- 接口回调是指可以把实现某一接口的类创建的对象赋给该接口声明的接口变量中。那么该接口变量就可以调用被类实现的接口中的方法。实际上，当接口变量调用被类实现的接口中的方法时，就是通知相应的对象调用接口的方法。

例如：
```
interface ePay {
	/**
	 * 电子支付的接口
	 */
	public void nfcPay();     //使用NFC功能支付
	public void epay();       //支付功能
	void addCard();           //添加公交卡功能
}

```

```
/**
 * 手机拍照功能的接口
 */
public interface photo {
	public void takePhoto();     //一般拍照功能
	void beautiyPhoto();          //美颜拍照功能
}
```

```
//手机类
public class Phone{
	
	String color;
	String size;
	
	void text(){
		System.out.println("发信息功能");
	}
	
	void call(){
		System.out.println("打电话功能");
	}
}
```

```
//继承了Phone类，实现了Photo和EPay接口的Iphone手机类
public class Iphone extends Phone implements photo, ePay{

	String size="6";
	String color="银色";
	
	@Override
	public void nfcPay() {
		// TODO Auto-generated method stub
		System.out.println("Iphone手机使用NFC功能支付");
	}

	@Override
	public void epay() {
		// TODO Auto-generated method stub
		System.out.println("Iphone使用电子支付功能");
	}

	@Override
	public void addCard() {
		// TODO Auto-generated method stub
		System.out.println("Iphone手机使用添加卡功能");
	}

	@Override
	public void takePhoto() {
		// TODO Auto-generated method stub
		System.out.println("Iphone使用拍照功能");
	}

	@Override
	public void beautiyPhoto() {
		// TODO Auto-generated method stub
		System.out.println("Iphone使用美颜拍照功能");
	}
}

```

```
public class Main{

	//参数是一个接口
	public void payMoney(ePay e){
		System.out.println("电子支付设备支付");
		e.nfcPay();
	}
	
	public void payMoney(double money){
		System.out.println("使用现金支付");
	}
	
	public static void main(String[] args) {
		// TODO Auto-generated method stub
        Iphone i7=new Iphone();
        Main main=new Main();
        
        i7.epay();    //Iphone使用电子支付
        
        //接口回调
        ePay epay=new Iphone(); 
        Iphone i701=(Iphone) epay; //还原——强制转换
        
        main.payMoney(i701);
	}

}

```

运行结果：

Iphone使用电子支付功能
电子支付设备支付
Iphone手机使用NFC功能支付

