# volatile是如何保证内存可见性和防止指令重排序的

## 1. 内存可见性

首先，要明确一下这个内存的含义。内存包含共享主存和高速缓存（工作内存），volatile关键字标识的变量，是指CPU从缓存读取数据时，要判断数据是否有效，如果缓存没有数据，则再从主存读取，主存就不存在是否有效的说法了。而内存一致性协议也是针对缓存的协议。

内存可见性意思是一个CPU核心对数据的修改，对其他CPU核心立即可见，这句话拆开了理解：

（1）CPU修改数据，首先是对工作内存的修改，也有人说被 volatile 修饰的变量不会拷贝副本到工作内存，而是直接修改主存，我觉得这个说法不对，CPU对数据对修改总是先修改工作内存，然后再同步主存，只不过对被 volatile 修饰的变量进行修改，会立刻同步到主存。假如只有一个线程修改 volatile 变量，那么这个变量在工作内存的副本会一直有效，CPU也不会每次修改都从主存读取 volatile 变量，只是每次修改后都会及时更新主存罢了。

（2）对其他核心可见。这个含义是，当一个 CPU 核心 A 修改完 volatile 变量，并且理解同步主存，如果 CPU 核心 B 的工作内存中也缓存了这个变量，那么 B 的这个变量将立即失效，当 B 想要读取或者修改这个变量的时候，B 必须从主存重新获取变量的值。

说了这么多，volatile 有什么用呢？它的一个很重要的作用就是用来修饰标记变量。

举个例子：

```java
public class VolatileTest implements Runnable {

    static boolean flag = true;

    @Override
    public void run() {
        while (flag) {
        }
        System.out.println("end......");
    }

    public static void main(String[] args) {
        new Thread(new VolatileTest()).start();
        try {
            Thread.sleep(1000);
        }
        catch (InterruptedException e) {
            e.printStackTrace();
        }
        flag = false;
        System.out.println("end main......");
    }
}
```

上面这个例子，子线程会一直运行而不会退出，原因就是 flag 不具备可见性，主线程和子线程刚开始都缓存了 flag，且值是true，后来主线程把 flag 改成了 false，但是子线程并不知道，它所看到的 flag 还是 true。如果把 flag 用 volatile 修改，那么主线修改成 false 后，子线程再次 while 循环的时候，就会发现它缓存的 flag 已经失效了，它会去主存重新读取 flag 的值。

实现的原理一般都是基于 CPU 的 MESI 协议（缓存一致性协议），其中 E 表示 Exclusive，S 表示 Shared，M 表示 Modified，I 表示 Invalid。如果一个 CPU 核心修改了数据，那么这个核心的数据状态就会更新为 M，同时其他的核心上的的数据状态就会更新成 I，这个是通过 CPU 多核之间的嗅探机制实现的。

但是，volatile 能否保证多线程操作一个共享变量的时候是线程安全的呢？答案是不能，我们可以看一下下面这个场景。

volatile 限定的是从缓存读取时刻的校验，如果两个 CPU 同时从各自缓存读取一个变量 n=1，此时变量 n 在各个 CPU 工作内存上都是有效的，并且同时修改了变量 n=n+1，再写回缓存，这个时候 n 的值就等于 2，而不是等于 3。因此 volatile 并不能保证线程安全，它是一种轻量级的线程同步机制。

## 2. 指令有序性

指令有序性涉及到内存栅栏（memory barrier），内存栅栏有两个能力：

1. 内存栅栏就像一套栅栏分割前后的代码，阻止栅栏前后的没有数据依赖性的代码进行指令重排序，保证程序在一定程度上的有序性。
2. 强制把写缓冲区/高速缓冲中的脏数据写回主内存，让缓存中相应的数据失效，保证数据的可见性。

首先，指令并不是代码行，指令是原子的，通过javap命令可以看到一行代码编译出来的指令，当然，像int i=1;这样的代码行也是原子操作。

在单例模式中，Instance inst = new Instance();   这一句，就不是原子操作，它可以分成三步原子指令：

1. 分配内存地址；
2. new一个Instance对象；
3. 将内存地址赋值给inst；

CPU为了提高执行效率，这三步操作的顺序可以是123，也可以是132，如果是132顺序的话，当把内存地址赋给inst后，inst指向的内存地址上面还没有new出来单例对象，这时候，如果就拿到inst的话，它其实就是空的，会报空指针异常。这就是为什么双重检查单例模式中，单例对象要加上volatile关键字。

内存屏障有三种类型和一种伪类型：

1. lfence：即读栅栏(Load Barrier)，在读指令前插入读栅栏，可以让高速缓存中的数据失效，重新从主内存加载数据，以保证读取的是最新的数据。
2. sfence：即写栅栏(Store Barrier)，在写指令之后插入写屏障，能让写入缓存的最新数据写回到主内存，以保证写入的数据立刻对其他线程可见。
3. mfence，即全能屏障，具备ifence和sfence的能力。
4. Lock前缀：Lock不是一种内存屏障，但是它能完成类似全能型内存栅栏的功能。

