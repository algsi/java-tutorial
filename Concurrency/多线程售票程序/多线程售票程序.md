# 多线程售票程序

售票是包含一系列动作的过程，有各种操作，例如查询票、收钱、数钱、出票等，其中有一个操作是每次卖掉一张，就将总的票数减去1。有10张票，如果一个人卖票，先做查票、收钱、数钱等各种操作，再将总的票数减去1，效率很低。如果多个人卖票，每个人都是做同样的操作，数钱、检查钱，最后将总的票数减1，这样效率高。但是有一个问题，如果出现两个人同时将总的票数减掉了1，例如，A、B两个人同时读取到票的总数是10，A从中减去1，同时B也从中减去1，总数显示是9，其实票只有8张。导致数据错误。

按照正常逻辑，同一时刻只允许一个人来从总票数中减去1，A读取总票数，再减去1的过程中，B必须等待，等A操作完了，B才能进行。其实票就是共享资源，一次只能由一个人访问。这里就要用到同步机制，即锁机制，使用关键词synchronized将读取总的票数，并减去1的操作锁定，使得一次只能由一个人访问。每个售票员就是一个线程，多个售票员进行同一项卖票任务。

synchronized原理是，执行synchronized部分代码的时候必须需要对象锁，而一个对象只有一个锁，只有执行完synchronized里面的代码后释放锁，其他线程才可以获得锁，那么就保证了同一时刻只有一个线程访问synchronized里面的代码。使得资源共享的关键是，只有一个实例，synchronized使用的是同一把锁，用实例的锁或者定义一个实例。这就需要使用实现Runnable接口的方式，实现多线程，这样传入的是同一个实例，共享了资源。而继承Thread的方式，每个实例都有一个锁，那就无法实现共享资源控制。

## 售票处程序

```java
package com.vin.ticket;

/**
 * created by Vintage
 * 售票处：
 */

public class TicketOffice implements Runnable {

    private int ticketCount = 20;         // 票的总数，这是共享资源，多个线程会访问
    private Object mutex = new Object();  // 自定义的锁，或者干脆使用实例的锁

    public void sellTicket() {
        synchronized (mutex) {
            if (ticketCount > 0) {
                System.out.println(Thread.currentThread().getName() + "正在卖票，售出的票号是："+ticketCount+"，还剩" + --ticketCount + "张票");
            } else {
                System.out.println("票已经卖完了！");
                return;
            }
        }
    }

    @Override
    public void run() {
        // 利用循环不停地售票
        while (ticketCount > 0){
            sellTicket();
            /**
             * 在同步代码块里面sleep,和不睡眠效果是一样 的,作用只是自已不执行,也不让线程执行。sleep不释放锁，而是抱着sleep。其他线程拿不到锁，也不能执行同步代码。wait()可以释放锁
             * 所以把sleep放到同步代码块的外面,这样卖完一张票就睡一会,让其他线程再卖,这样所有的线程都可以卖票
             */
            try {
                Thread.sleep(100);
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
        }
    }
}

```

## 开始售票

```java
package com.vin.ticket;

/**
 * created by Vintage
 */
public class TicketMain {

    public static void main(String[] args) {
        TicketOffice runTicekt = new TicketOffice();           //只定义了一个实例，这就只有一个Object mutex = new Object()，即一个锁。
        Thread th1 = new Thread(runTicekt, "窗口1");    //每个线程等其他线程释放该锁后，才能执行
        Thread th2 = new Thread(runTicekt, "窗口2");
        Thread th3 = new Thread(runTicekt, "窗口3");
        Thread th4 = new Thread(runTicekt, "窗口4");
        th1.start();
        th2.start();
        th3.start();
        th4.start();
    }
}
```

## 运行结果

```language
窗口1正在卖票，售出的票号是：10，还剩9张票
窗口3正在卖票，售出的票号是：9，还剩8张票
窗口4正在卖票，售出的票号是：8，还剩7张票
窗口2正在卖票，售出的票号是：7，还剩6张票
窗口2正在卖票，售出的票号是：6，还剩5张票
窗口1正在卖票，售出的票号是：5，还剩4张票
窗口3正在卖票，售出的票号是：4，还剩3张票
窗口4正在卖票，售出的票号是：3，还剩2张票
窗口2正在卖票，售出的票号是：2，还剩1张票
窗口4正在卖票，售出的票号是：1，还剩0张票
票已经卖完了！
票已经卖完了！
```

可以看到最后票售完的信息打印了两次，因为我们的 run() 方法并不是同步的，当 ticketCount 还不为0时，可能有多个进入 run() 方法要进行售票，但就在进入之后售票之前，票刚好卖完，再逐个进入同步语句块中发现票已经卖完了。

如果我们把第一个程序的同步语句去掉，留下售票语句，如下，注释掉了：

```java
public void sellTicket() {
//        synchronized (mutex) {
        if (ticketCount > 0) {
            System.out.println(Thread.currentThread().getName() + "正在卖票，售出的票号是："+ticketCount+"，还剩" + --ticketCount + "张票");
        } else {
            System.out.println("票已经卖完了！");
            return;
        }
//        }
}
```

那么输出会是怎样呢？

```language
窗口1正在卖票，售出的票号是：10，还剩8张票
窗口4正在卖票，售出的票号是：8，还剩7张票
窗口2正在卖票，售出的票号是：10，还剩9张票
窗口3正在卖票，售出的票号是：7，还剩6张票
窗口2正在卖票，售出的票号是：6，还剩5张票
窗口4正在卖票，售出的票号是：6，还剩5张票
窗口1正在卖票，售出的票号是：6，还剩5张票
窗口3正在卖票，售出的票号是：6，还剩4张票
窗口3正在卖票，售出的票号是：4，还剩2张票
窗口4正在卖票，售出的票号是：4，还剩3张票
窗口1正在卖票，售出的票号是：2，还剩1张票
窗口2正在卖票，售出的票号是：4，还剩3张票
窗口1正在卖票，售出的票号是：1，还剩0张票
窗口3正在卖票，售出的票号是：1，还剩0张票
窗口2正在卖票，售出的票号是：1，还剩0张票
窗口4正在卖票，售出的票号是：1，还剩0张票
```

可以看出，已经不按常理出牌了。。。