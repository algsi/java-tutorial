# 锁的分类

锁是多线程并发问题中的重要组成。这里就先来介绍有哪些类型的锁。

锁分为以下几种：

- 乐观锁 / 悲观锁
- 独享锁 / 共享锁
- 公平锁 / 非公平锁
- 互斥锁 / 读写锁
- 可重入锁
- 分段锁
- 偏向锁 / 轻量级锁 / 重量级锁
- 自旋锁

## 1. 乐观锁 / 悲观锁

乐观锁与悲观锁并不是特指某两种类型的锁，是人们定义出来的概念或思想，主要是指看待并发同步的角度。

 乐观锁总是认为不存在或者很少并发问题，每次去取数据的时候，认为不会有其他线程对数据进行修改，因此**不会上锁**。但是在更新数据时会判断其他线程在这之前有没有对数据进行修改，一般会使用“版本号机制”或“CAS操作”来实现。  

 悲观锁总是认为对同一个数据的操作存在并发问题，因此对于同一份数据的并发操作，悲观锁采取**加锁**的形式。悲观的认为，不加锁并发操作一定会出问题。在对任意记录进行修改前，先尝试为该记录加上排他锁（exclusive locking）。

## 2. 独享锁 / 共享锁

这两种锁也是一种概念。

独享锁也可称为排他锁，具备强烈的排他性质，该锁一次只能被一个线程所持有。

共享锁顾名思义就是该锁可以被多个线程同时持有。

举例：

- synchronized 和 ReentrantLock 都是独享锁
- 读写锁 ReentrantReadWriteLock 中的读锁 ReadLock 是共享锁，写锁 WriteLock 是独享锁，并且一个线程获取来写锁之后，其他线程不能获取读锁。

独享锁与共享锁通过 AQS(AbstractQueuedSynchronizer) 来实现的，通过实现不同的方法，来实现独享或者共享。

## 3. 互斥锁 / 读写锁

上面讲的独享锁/共享锁就是一种概念，互斥锁和读写锁是具体的实现。

互斥锁的具体实现就是synchronized、ReentrantLock。ReentrantLock 是 JDK1.5 的新特性，采用 ReentrantLock 可以完全替代替换 synchronized 传统的锁机制，更加灵活。

读写锁的具体实现就是读写锁 ReadWriteLock。

## 4. 可重入锁

可重入锁又称为递归锁。对于同一个线程在外层方法获取锁的时候，在进入内层方法时也会自动获取锁。

优点：避免死锁。

举例：ReentrantLock、synchronized 和 ReentrantReadWriteLock。

## 5. 公平锁 / 非公平锁

公平锁是指多个线程按照申请锁的顺序来获取锁。这种锁有：ReentrantLock

非公平锁是指多个线程获取锁的顺序并不是按照申请锁的顺序，有可能后申请的线程比先申请的线程优先获取锁。可能会造成优先级反转或者饥饿现象。这种锁有：ReentrantLock 和 synchronized。

## 6. 分段锁

分段锁并不是具体的一种锁，只是一种锁的设计。

分段锁的设计目的是细化锁的粒度，当操作不需要更新整个数组的时候，就仅仅针对数组中的一项进行加锁操作。JDK 1.8 之前的 CurrentHashMap 底层就用了分段锁，使用Segment，就可以进行并发使用了。

## 7. 偏向锁 / 轻量级锁 / 重量级锁

JDK 1.6 为了减少获取锁和释放锁带来的性能损耗，在 JDK 1.6 里引入了4种锁状态：**无锁**，**偏向锁**，**轻量级锁**，**重量级锁**，它会随着多线程竞争的逐渐升级，但不能降级。

研究发现大多数情况下，锁不仅不存在多线程竞争，而且总是由同一线程多次获得，为了不让这个线程每次获得锁都需要 CAS 操作的性能消耗，就引入了偏向锁。

当一个线程访问对象并获取锁时，会在对象头里存储锁偏向的这个线程的ID，以后该线程再访问该对象时只需判断对象头的Mark Word里是否有这个线程的ID，如果有就不需要进行CAS操作，这就是偏向锁。

当线程竞争更激烈时，偏向锁就会升级为轻量级锁，轻量级锁认为虽然竞争是存在的，但是理想情况下竞争的程度很低，通过自旋方式等待上一个线程释放锁，但是当自旋超过了一定次数，或者一个线程持有锁，一个线程在自旋，又来了第三个线程访问时（竞争继续加大了），轻量级锁就会膨胀为重量级锁，重量级锁就是Synchronized，重量级锁会使除了此时拥有锁的线程以外的线程都阻塞。



## 8. 自旋锁

如果持有锁的线程能在很短时间内释放锁资源，那么那些等待竞争锁的线程就不需要做内核态和用户态之间的切换进入阻塞挂起状态，它们只需要等一等(自旋)，等持有锁的线程释放锁后即可立即获取锁，这样就避免用户线程和内核的切换的消耗。

自旋锁是指尝试获取锁的线程不会立即阻塞，而是采用循环的方式去尝试获取锁，这样的好处是减少线程上下文切换的消耗，缺点是循环会消耗CPU。

线程自旋是需要消耗 CPU 的，说白了就是让 CPU 在做无用功，如果一直获取不到锁，那线程也不能一直占用 CPU 自旋做无用功，所以需要设定一个自旋等待的最大时间。

自旋锁的优点：自旋锁尽可能的减少线程的阻塞，这对于锁的竞争不激烈，且占用锁的时间非常短的代码块来说性能能大幅度的提升，因为自旋的消耗会小于线程阻塞挂起再唤醒的操作的消耗，这些操作会导致线程发生两次上下文切换。

自旋锁的缺点：如果锁的竞争激烈，或者说持有锁的线程需要长时间持有锁执行同步代码块，这时就不太适合使用自旋锁了，因为自旋锁在获取到锁之前一直都在占用 CPU 做无用功，线程自旋的消耗大于线程阻塞挂起操作的消耗。

自旋锁的时间阈值（1.6引入了适应自旋锁）：自旋锁的目的是占着 CPU 的资源不释放，等到获取到锁以便立即进行处理。但是如何去选择自旋的执行时间呢？如果自旋执行时间太长，会有大量的线程处于自旋状态占用 CPU 资源，进而会影响整体系统的性能。因此自旋的周期选的额外重要！

JVM 对于自旋周期的选择，JDK 1.5 这个限度是一定的写死的，在 1.6 引入了适应性自旋锁，适应性自旋锁意味着自旋的时间不在是固定的了，而是由前一次在同一个锁上的自旋时间以及锁的拥有者的状态来决定，基本认为一个线程上下文切换的时间是最佳的一个时间，同时 JVM 还针对当前 CPU 的负荷情况做了较多的优化，如果平均负载小于 CPUs 则一直自旋，如果有超过(CPUs/2)个线程正在自旋，则后来线程直接阻塞，如果正在自旋的线程发现 Owner 发生了变化则延迟自旋时间(自旋计数)或进入阻塞，如果 CPU 处于节电模式则停止自旋，自旋时间的最坏情况是 CPU的存储延迟(CPU A 存储了一个数据，到 CPU B 得知这个数据直接的时间差)，自旋时会适当放弃线程优先级之间的差异。

自旋锁的开启

JDK1.6 中-XX:+UseSpinning 开启; 

-XX:PreBlockSpin=10 为自旋次数; 

JDK1.7 后，去掉此参数，由 jvm 控制;